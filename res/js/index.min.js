!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t,i=e();for(t in i)("object"==typeof exports?exports:n)[t]=i[t]}}(this,function(){return f=[function(module,exports){eval('// file.js\nvar file = null;\nvar screen = null;\naxios.get(window.prefix + "/api/comm/initData", {}).then(initData => {\n  let resData = initData.data;\n  screen = new Vue({\n    el: \'#screenApp\',\n    data: function () {\n      return {\n        startCapture: true,\n        stream: null,\n        chunks: [],\n        mediaRecorder: null,\n        recording: null,\n        checkDisableIntervelId: 0,\n        list: [],\n        times: 0,\n        interverlId: 0,\n        size: 0\n      };\n    },\n    computed: {\n      list: function () {\n        return this.list;\n      }\n    },\n    methods: {\n      getMediaPlay: function () {\n        if (navigator.getDisplayMedia) {\n          return navigator.getDisplayMedia({\n            video: true,\n            audio: true\n          });\n        } else if (navigator.mediaDevices.getDisplayMedia) {\n          return navigator.mediaDevices.getDisplayMedia({\n            video: true,\n            audio: true\n          });\n        } else if (navigator.mediaDevices.getUserMedia) {\n          return navigator.mediaDevices.getUserMedia({\n            video: {\n              mediaSource: \'screen\'\n            },\n            audio: true\n          });\n        } else {\n          return navigator.getUserMedia({\n            video: {\n              \'mandatory\': {\n                \'chromeMediaSource\': \'desktop\'\n              }\n            },\n            audio: true\n          });\n        }\n      },\n      startScreen: async function () {\n        let that = this;\n        this.startCapture = false;\n        this.checkDisableIntervelId = setInterval(function () {\n          if (that.mediaRecorder == null) {\n            that.startCapture = true;\n          } else {\n            clearInterval(that.checkDisableIntervelId);\n            that.startCapture = false;\n          }\n        }, 500);\n\n        if (this.recording) {\n          window.URL.revokeObjectURL(this.recording);\n        }\n\n        this.chunks = [];\n        this.recording = null;\n\n        try {\n          this.stream = await this.getMediaPlay();\n        } catch (error) {\n          console.log(error);\n        }\n\n        if (this.stream == null) {\n          if (window.layer) {\n            layer.msg("获取设备录制权限失败");\n          }\n\n          window.Bus.$emit("changeScreenState", false);\n          return;\n        }\n\n        this.mediaRecorder = new MediaRecorder(this.stream, {\n          mimeType: \'video/webm\'\n        });\n        this.mediaRecorder.addEventListener(\'dataavailable\', event => {\n          if (event.data && event.data.size > 0) {\n            that.size += event.data.size;\n            that.chunks.push(event.data);\n          }\n        });\n        this.mediaRecorder.start(10); //计算时间\n\n        this.interverlId = setInterval(() => {\n          that.times += 1;\n          window.Bus.$emit("changeScreenTimes", that.times);\n        }, 1000);\n\n        if (window.layer) {\n          layer.msg("开始录制，再次点击录制即可停止");\n        }\n      },\n      stopScreen: function (callback) {\n        this.startCapture = true;\n        let hasErr = false;\n\n        try {\n          this.mediaRecorder.stop();\n        } catch (e) {\n          if (window.layer) {\n            layer.msg("录制不完整，如需停止录制，请点击本页面的停止按钮来停止录制");\n          }\n\n          hasErr = true;\n        }\n\n        this.stream.getTracks().forEach(track => track.stop());\n        this.recording = window.URL.createObjectURL(new Blob(this.chunks, {\n          type: \'video/webm\'\n        }));\n        clearInterval(this.interverlId);\n        this.mediaRecorder = null;\n        this.chunks = [];\n        this.stream = null;\n        let data = {\n          donwId: \'d_\' + parseInt(Math.random(10000) * 10000),\n          times: this.times,\n          src: this.recording,\n          size: this.size\n        };\n        this.times = 0;\n        this.size = 0;\n        window.Bus.$emit("changeScreenTimes", 0);\n        callback(data);\n\n        if (window.layer && !hasErr) {\n          layer.msg("录制完成，请在接收文件列表查看");\n        }\n\n        return;\n      }\n    },\n    mounted: function () {\n      window.Bus.$on("startScreen", this.startScreen);\n      window.Bus.$on("stopScreen", this.stopScreen);\n    }\n  });\n  file = new Vue({\n    el: \'#fileApp\',\n    data: function () {\n      let socket = null;\n\n      if (io) {\n        socket = io(resData.wsHost);\n      }\n\n      return {\n        socket: socket,\n        config: resData.rtcConfig,\n        options: resData.options,\n        isJoined: false,\n        showReceiveFile: false,\n        showSendFile: false,\n        showReceiveTxt: false,\n        showLogs: false,\n        numSendFile: 150,\n        numReceiveFile: 150,\n        numReceiveTxt: 150,\n        numLogs: 150,\n        currentMenu: 1,\n        logsHeight: 0,\n        allManCount: 0,\n        isTxtMode: false,\n        txtEditId: 0,\n        isRealContentMode: false,\n        //是否使用富文本内容\n        nickName: "",\n        //本人名称\n        socketId: 0,\n        //本人的id\n        roomId: "10086",\n        //房间号\n        recoderId: 0,\n        //记录id\n        fileReader: null,\n        //文件读取对象\n        rtcConns: {},\n        //远程连接\n        remoteMap: {},\n        //远程连接map\n        chunkSize: 256 * 1024,\n        //一块256kb\n        offset: 0,\n        //当前文件分片位移\n        fileName: null,\n        //文件名称\n        hasSending: false,\n        //是否有正在发送的文件\n        allSended: false,\n        //当前文件是否全部发送给房间内所有用户\n        currentReceiveSize: 0,\n        //统计收到文件的大小\n        chooseFile: null,\n        //选择的文件\n        sendFileList: [],\n        //发过文件的列表\n        receiveFileList: [],\n        //接收文件的列表\n        receiveTxtList: [],\n        //接收的文字列表 \n        logs: [],\n        //记录日志\n        isScreen: false,\n        //是否在录屏中\n        screenTimes: 0,\n        //当前录屏时间\n        chatingList: [] //公共聊天频道内容\n\n      };\n    },\n    computed: {\n      createDisabled: function () {\n        return this.isJoined || this.fileName;\n      },\n      exsitDisabled: function () {\n        return !this.isJoined;\n      },\n      sending: function () {\n        return this.hasSending;\n      },\n      uploadDisabled: function () {\n        return !this.fileName || this.allSended;\n      },\n      showSendFileList: function () {\n        return this.sendFileList && this.sendFileList.length > 5;\n      },\n      noOthersInRoom: function () {\n        return Object.keys(this.remoteMap).length === 0;\n      },\n      isMobile: function () {\n        return navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n      }\n    },\n    watch: {\n      hasSending: function (newV, oldV) {},\n      allManCount: function (newV, oldV) {},\n      currentMenu: function (newV, oldV) {},\n      allSended: function (newV, oldV) {},\n      fileName: function (newV, oldV) {\n        this.chooseFile = this.$refs[\'self-file\'].files[0];\n        if (!this.chooseFile) return;\n        if (!this.socketId) return;\n        this.$refs[\'sendProgress\'].max = this.chooseFile.size;\n        this.socket.emit(\'message\', {\n          emitType: "sendFileInfo",\n          name: this.chooseFile.name,\n          type: this.chooseFile.type,\n          size: this.chooseFile.size,\n          room: this.roomId,\n          from: this.socketId,\n          recoderId: this.recoderId\n        });\n        this.allSended = false;\n        let idList = [];\n\n        for (let id in this.remoteMap) {\n          this.setRemoteInfo(id, {\n            status: 0\n          });\n          idList.push(id);\n        }\n\n        if (this.socketId) {\n          let toIdStr = "";\n\n          if (idList.length > 0) {\n            toIdStr += "发送给房间的 " + idList[0] + " ...等" + idList.length + "人";\n          }\n\n          for (let id in this.remoteMap) {\n            this.sendFileList.push({\n              id: id,\n              name: this.chooseFile.name,\n              size: this.chooseFile.size,\n              type: this.chooseFile.type,\n              process: 0,\n              done: false,\n              toIdStr: toIdStr,\n              start: 0,\n              cost: 0\n            });\n          }\n        }\n      },\n      currentReceiveSize: function (newV, oldV) {\n        this.currentReceiveSize = newV;\n      },\n      remoteMap: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      receiveFileList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      receiveTxtList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      sendFileList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      chatingList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      }\n    },\n    methods: {\n      startScreen: function () {\n        if (this.isMobile) {\n          if (window.layer) {\n            layer.msg("移动端暂不支持屏幕录制");\n          }\n\n          return;\n        }\n\n        if (!this.isScreen) {\n          window.Bus.$emit("startScreen");\n        } else {\n          window.Bus.$emit("stopScreen", res => {\n            this.receiveFileList.push({\n              id: "网页录屏",\n              href: res.src,\n              style: \'color: #ff5722;text-decoration: underline;\',\n              name: \'screen-recording-\' + res.donwId + \'.mp4\',\n              type: "webm/mp4",\n              size: res.size,\n              process: 100,\n              done: true,\n              start: 0,\n              cost: res.times\n            });\n          });\n        }\n\n        this.isScreen = !this.isScreen;\n      },\n      shareUrl: function () {\n        document.querySelector("#shareUrl").setAttribute("data-clipboard-text", "https://im.iamtsm.cn/file#r=" + this.roomId);\n        var clipboard = new ClipboardJS(\'#shareUrl\');\n        clipboard.on(\'success\', function (e) {\n          e.clearSelection();\n\n          if (window.layer) {\n            layer.msg("复制房间链接成功!");\n          }\n        });\n      },\n      copyTxt: function (id, content) {\n        document.querySelector("#" + id).setAttribute("data-clipboard-text", content);\n        var clipboard = new ClipboardJS(\'#\' + id);\n        clipboard.on(\'success\', function (e) {\n          e.clearSelection();\n\n          if (window.layer) {\n            layer.msg("复制内容成功!");\n          }\n        });\n      },\n      //分享进入\n      handlerRoomHistory: function () {\n        let that = this;\n        var hash = window.location.hash || "";\n\n        if (hash && hash.includes("#")) {\n          let roomIdArgs = hash.split("r=");\n\n          if (roomIdArgs && roomIdArgs.length > 1) {\n            this.roomId = (roomIdArgs[1] + "").replace(/\\s*/g, "").substr(0, 14);\n\n            if (window.layer) {\n              layer.confirm("进入房间" + this.roomId, index => {\n                window.location.hash = "";\n                layer.close(index);\n                that.createRoom();\n              }, index => {\n                that.roomId = "";\n                window.location.hash = "";\n                layer.close(index);\n              });\n              this.addPopup("你通过分享加入了房间号为 " + this.roomId);\n              this.logs.push("你通过分享加入了房间号为 " + this.roomId);\n            }\n          }\n        }\n      },\n      chating: function () {\n        let that = this;\n\n        if (window.layer) {\n          let options = {\n            type: 1,\n            fixed: false,\n            //不固定\n            maxmin: false,\n            area: [\'600px\', \'600px\'],\n            title: "公共聊天频道",\n            success: function (layero, index) {\n              let active = null;\n\n              if (that.currentMenu === 1) {\n                active = that.$refs[\'btnHome\'];\n              } else if (that.currentMenu === 2) {\n                active = that.$refs[\'btnReceive\'];\n              } else if (that.currentMenu === 3) {\n                active = that.$refs[\'btnTxt\'];\n              }\n\n              document.querySelector(".layui-layer-title").style.borderTopRightRadius = "15px";\n              document.querySelector(".layui-layer-title").style.borderTopLeftRadius = "15px";\n              document.querySelector(".layui-layer").style.borderRadius = "15px";\n              document.querySelector(".chating-content").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n              document.querySelector(".layui-textarea").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n              document.querySelector(".layui-layer-title").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n              document.querySelector(".layui-layer").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n              that.chatingTpl();\n            },\n            content: `\n                            <div class="layui-col-sm12" style="padding: 15px;">\n                                <div class="layui-card chating-content" id="chating_tpl_view" style="padding: 5px;"> </div>\n                                <script id="chating_tpl" type="text/html">\n                                    {{#  layui.each(d, function(index, info){ }}\n                                    <div style="margin-bottom: 30px;display: inline-flex;">\n                                        <a > <img style="width: 32px; height: 32px;" src="/image/44826979.png" alt="img"> </a>\n                                        <div style="margin-left: 15px; margin-top: -5px;">\n                                            <div style="word-break: break-all;"> <small>房间号: <b>{{info.room}}</b></small> - <small>用户: <b>{{info.socketId}}</b></small> - <small>时间: <b>{{info.time}}</b></small> </div>\n                                            <div style="margin-top: 5px;word-break: break-all;">说: <b style="font-weight: bold; font-size: large;"> {{info.msg}} </b></div>\n                                        </div>\n                                    </div>\n                                    {{#  }); }}\n                                <\/script>\n                            </div>\n                            <div style="bottom: 0px; position: absolute; width: 100%; padding: 20px;">\n                                <textarea maxlength="50000" id="blog_comment" class="layui-textarea" placeholder="文明发言，理性交流 ~"></textarea>\n                                <button style="float: right;margin-top: 10px;" onclick="sendChating()" type="button" class="layui-btn layui-btn-normal layui-btn-sm">发言</button>\n                            </div>\n                        `\n          };\n\n          if (this.isMobile) {\n            delete options.area;\n          }\n\n          let index = layer.open(options);\n\n          if (this.isMobile) {\n            layer.full(index);\n          }\n        }\n      },\n      escapeHtml: function () {\n        var entityMap = {\n          escape: {\n            \'&\': \'&amp;\',\n            \'<\': \'&lt;\',\n            \'>\': \'&gt;\',\n            \'"\': \'&quot;\',\n            "\'": \'&apos;\'\n          },\n          unescape: {\n            \'&amp;\': "&",\n            \'&apos;\': "\'",\n            \'&gt;\': ">",\n            \'&lt;\': "<",\n            \'&quot;\': \'"\'\n          }\n        };\n        var entityReg = {\n          escape: RegExp(\'[\' + Object.keys(entityMap.escape).join(\'\') + \']\', \'g\'),\n          unescape: RegExp(\'(\' + Object.keys(entityMap.unescape).join(\'|\') + \')\', \'g\')\n        }; // 将HTML转义为实体\n\n        function escape(html) {\n          if (typeof html !== \'string\') return \'\';\n          return html.replace(entityReg.escape, function (match) {\n            return entityMap.escape[match];\n          });\n        } // 将实体转回为HTML\n\n\n        function unescape(str) {\n          if (typeof str !== \'string\') return \'\';\n          return str.replace(entityReg.unescape, function (match) {\n            return entityMap.unescape[match];\n          });\n        }\n\n        return {\n          escape: escape,\n          unescape: unescape\n        };\n      },\n      chatingTpl: function () {\n        let tpl_html = document.getElementById("chating_tpl");\n        let tpl_view_html = document.getElementById("chating_tpl_view");\n\n        if (tpl_html && tpl_view_html) {\n          this.tpl(tpl_html, this.chatingList, tpl_view_html);\n          let chatDom = document.querySelector("#chating_tpl_view");\n          let chatDomHeight = chatDom.clientHeight;\n          let height = 0;\n\n          if (this.isMobile) {\n            height = document.documentElement.clientHeight - 235;\n          } else {\n            height = 350;\n          }\n\n          if (chatDomHeight > height) {\n            chatDom.style.height = height + "px";\n            chatDom.style.overflowY = "scroll";\n          } else {\n            chatDom.style.overflowY = "none";\n          }\n        }\n      },\n      tpl: function (tpl_html, data, tpl_view_html) {\n        if (window.laytpl) {\n          laytpl(tpl_html.innerHTML).render(data, html => {\n            tpl_view_html.innerHTML = html;\n          });\n        }\n      },\n      sendChating: function () {\n        let content = document.querySelector("#blog_comment").value;\n\n        if (!this.createDisabled) {\n          if (window.layer) {\n            layer.msg("请先加入房间，才能发言哦");\n          }\n\n          return;\n        }\n\n        if (content === \'\' || content === undefined) {\n          if (window.layer) {\n            layer.msg("请先填写内容哦");\n          }\n\n          return;\n        }\n\n        if (content.length > 1000) {\n          if (window.layer) {\n            layer.msg("内容太长啦，不能超过1000个字");\n          }\n\n          return;\n        }\n\n        this.socket.emit(\'chating\', {\n          recoderId: this.recoderId,\n          msg: content,\n          room: this.roomId,\n          socketId: this.socketId,\n          time: new Date().toLocaleString()\n        });\n        document.querySelector("#blog_comment").value = \'\';\n      },\n      refleshRoom: function () {\n        if (!this.createDisabled) {\n          this.roomId = parseInt(Math.random() * 100000);\n          this.addPopup("你刷新了房间号, 当前房间号为 " + this.roomId);\n          this.logs.push("你刷新了房间号, 当前房间号为 " + this.roomId);\n          $("#refresh").removeClass("layui-anim-rotate");\n          setTimeout(() => {\n            $("#refresh").addClass("layui-anim-rotate");\n          }, 50);\n        }\n      },\n      genNickName: function () {\n        // 获取指定范围内的随机数\n        function randomAccess(min, max) {\n          return Math.floor(Math.random() * (min - max) + max);\n        } // 解码\n\n\n        function decodeUnicode(str) {\n          //Unicode显示方式是\\u4e00\n          str = "\\\\u" + str;\n          str = str.replace(/\\\\/g, "%"); //转换中文\n\n          str = unescape(str); //将其他受影响的转换回原来\n\n          str = str.replace(/%/g, "\\\\");\n          return str;\n        }\n\n        function getRandomName(len) {\n          let name = "";\n\n          for (let i = 0; i < len; i++) {\n            let unicodeNum = "";\n            unicodeNum = randomAccess(0x4e00, 0x9fa5).toString(16);\n            name += decodeUnicode(unicodeNum);\n          }\n\n          return name;\n        }\n\n        return getRandomName(4);\n      },\n      addPopup: function (msg) {\n        window.Bus.$emit("addPopup", msg);\n      },\n      cleanPopup: function () {\n        window.Bus.$emit("popupMap");\n      },\n      clickChooseFile: function () {\n        this.$refs[\'self-file\'].click();\n\n        if (!this.createDisabled) {\n          this.addPopup("请先创建/加入房间后，再选择文件");\n          this.logs.push("请先创建/加入房间后，再选择文件");\n        }\n\n        if (this.noOthersInRoom) {\n          this.addPopup("请用户方都加入房间后，再选择文件");\n          this.logs.push("请用户方都加入房间后，再选择文件");\n        }\n      },\n      sendTxt: function () {\n        if (!this.createDisabled) {\n          if (window.layer) {\n            layer.msg("请先加入房间，再发送内容");\n          }\n\n          return;\n        }\n\n        if (this.noOthersInRoom) {\n          if (window.layer) {\n            layer.msg("房间内至少需要两个人才能发送内容");\n          }\n\n          return;\n        }\n\n        if (this.isRealContentMode) {\n          let realContent = layedit.getContent(this.txtEditId);\n\n          if (realContent.length <= 0) {\n            if (window.layer) {\n              layer.msg("请输入发送的富文本内容");\n            }\n\n            return;\n          }\n\n          if (realContent.length > 1000) {\n            if (window.layer) {\n              layer.msg("富文本文字内容过长，长度最多1w单词!");\n            }\n\n            return;\n          }\n\n          this.socket.emit(\'message\', {\n            emitType: "sendTxt",\n            content: encodeURIComponent(realContent),\n            room: this.roomId,\n            from: this.socketId,\n            recoderId: this.recoderId\n          });\n\n          if (window.layer) {\n            if (window.layui && window.layedit) {\n              this.txtEditId = window.layedit.build(\'txt\', {\n                tool: [\'strong\', \'italic\', \'underline\', \'del\', \'|\', \'left\', \'center\', \'right\', \'face\']\n              });\n            }\n\n            this.sendFileList.push({\n              id: "txt",\n              name: realContent,\n              size: realContent.length,\n              type: "富文本内容",\n              process: 100,\n              done: true,\n              toIdStr: "",\n              start: 0,\n              cost: 0\n            });\n            layer.msg("富文本内容发送完毕");\n          }\n        } else {\n          let content = layedit.getText(this.txtEditId);\n\n          if (content.length <= 0) {\n            if (window.layer) {\n              layer.msg("请输入发送的文本内容");\n            }\n\n            return;\n          }\n\n          if (content.length > 1000) {\n            if (window.layer) {\n              layer.msg("文字内容过长，最多1000单词!");\n            }\n\n            return;\n          }\n\n          this.socket.emit(\'message\', {\n            emitType: "sendTxt",\n            content: encodeURIComponent(content),\n            room: this.roomId,\n            from: this.socketId,\n            recoderId: this.recoderId\n          });\n\n          if (window.layer) {\n            if (window.layui && window.layedit) {\n              this.txtEditId = window.layedit.build(\'txt\', {\n                tool: [\'strong\', \'italic\', \'underline\', \'del\', \'|\', \'left\', \'center\', \'right\', \'face\']\n              });\n            }\n\n            this.sendFileList.push({\n              id: "txt",\n              name: content,\n              size: content.length,\n              type: "文本内容",\n              process: 100,\n              done: true,\n              toIdStr: "",\n              start: 0,\n              cost: 0\n            });\n            layer.msg("内容发送完毕");\n          }\n        }\n      },\n      clickHome: function (show = true) {\n        this.currentMenu = 1;\n        let active = this.$refs[\'btnHome\'];\n        document.body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        document.querySelector(".chooseFileName").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        let menuBorder = document.querySelector(".menu__border");\n        let box = active.getBoundingClientRect();\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickSendFile();\n        }\n      },\n      clickReceive: function (show = true) {\n        this.currentMenu = 2;\n        let active = this.$refs[\'btnReceive\'];\n        document.body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        document.querySelector(".chooseFileName").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        let menuBorder = document.querySelector(".menu__border");\n        let box = active.getBoundingClientRect();\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickReceiveFile();\n        }\n      },\n      clickTxt: function (show = true) {\n        this.currentMenu = 3;\n        let active = this.$refs[\'btnTxt\'];\n        document.body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        let menuBorder = document.querySelector(".menu__border");\n        let box = active.getBoundingClientRect();\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickReceiveTxt();\n        }\n      },\n      //文件大小\n      getFileSizeStr: function (size) {\n        let sizeStr = (size / 1048576).toString();\n        let head = sizeStr.split(".")[0];\n        let tail = "";\n\n        if (sizeStr.split(".")[1]) {\n          tail = sizeStr.split(".")[1].substr(0, 3);\n        }\n\n        return head + \'.\' + tail + "M";\n      },\n      //点击下载文件\n      clickReceiveFile: function () {\n        this.showReceiveFile = !this.showReceiveFile;\n\n        if (this.showReceiveFile) {\n          this.numReceiveFile = 50;\n        } else {\n          this.numReceiveFile = 150;\n        }\n      },\n      //点击接收文字\n      clickReceiveTxt: function (change = true) {\n        if (change) {\n          this.isTxtMode = !this.isTxtMode;\n\n          if (window.layui && window.layedit) {\n            this.txtEditId = window.layedit.build(\'txt\', {\n              tool: [\'strong\', \'italic\', \'underline\', \'del\', \'|\', \'left\', \'center\', \'right\', \'face\']\n            });\n          }\n        }\n\n        this.showReceiveTxt = !this.showReceiveTxt;\n\n        if (this.showReceiveTxt) {\n          this.numReceiveTxt = 50;\n        } else {\n          this.numReceiveTxt = 150;\n        }\n      },\n      //点击发送文件\n      clickSendFile: function () {\n        this.showSendFile = !this.showSendFile;\n\n        if (this.showSendFile) {\n          this.numSendFile = 50;\n        } else {\n          this.numSendFile = 150;\n        }\n      },\n      //点击查看日志\n      clickLogs: function () {\n        this.showLogs = !this.showLogs;\n\n        if (this.showLogs) {\n          this.numLogs = 50;\n        } else {\n          this.numLogs = 150;\n        }\n      },\n      //创建房间\n      createRoom: function () {\n        this.roomId = this.roomId.toString().replace(/\\s*/g, "");\n\n        if (this.roomId === null || this.roomId === undefined || this.roomId === \'\') {\n          alert("请先填写房间号");\n          return;\n        }\n\n        if (this.fileName != null) {\n          alert("请先加入房间再选文件");\n          return;\n        }\n\n        if (this.roomId) {\n          if (this.roomId.toString().length > 15) {\n            alert("房间号太长啦");\n            return;\n          }\n\n          this.socket.emit(\'createAndJoin\', {\n            room: this.roomId\n          });\n          this.isJoined = true; // this.nickName = this.genNickName();\n\n          this.addPopup("你进入了房间" + this.roomId);\n          this.logs.push("你进入了房间" + this.roomId);\n        }\n      },\n      //退出房间\n      exitRoom: function () {\n        if (this.roomId) {\n          this.socket.emit(\'exit\', {\n            from: this.socketId,\n            room: this.roomId,\n            recoderId: this.recoderId\n          });\n        }\n\n        for (let i in this.rtcConns) {\n          let rtcConnect = this.rtcConns[i];\n          rtcConnect.close();\n          rtcConnect = null;\n        }\n\n        window.location.reload();\n      },\n      //获取rtc缓存连接\n      getRtcConnect: function (id) {\n        return this.rtcConns[id];\n      },\n      //创立链接\n      createRtcConnect: function (id) {\n        if (id === undefined) {\n          return;\n        }\n\n        let that = this;\n        let rtcConnect = new RTCPeerConnection(this.config);\n\n        rtcConnect.onicecandidate = e => {\n          that.iceCandidate(rtcConnect, id, e);\n        }; //保存peer连接\n\n\n        this.rtcConns[id] = rtcConnect;\n\n        if (!this.remoteMap[id]) {\n          Vue.set(this.remoteMap, id, {\n            id: id\n          });\n        } //数据通道\n\n\n        this.initSendDataChannel(id);\n\n        rtcConnect.onremovestream = e => {\n          that.removeStream(rtcConnect, id, e);\n        };\n\n        return rtcConnect;\n      },\n      //获取本地与远程连接\n      getOrCreateRtcConnect: function (id) {\n        let rtcConnect = this.getRtcConnect(id);\n\n        if (typeof rtcConnect == \'undefined\') {\n          rtcConnect = this.createRtcConnect(id);\n        }\n\n        return rtcConnect;\n      },\n      //连接创立时建立 send/receive Channel链接\n      initSendDataChannel: function (id) {\n        let that = this;\n        let sendChannel = this.rtcConns[id].createDataChannel(\'sendDataChannel\');\n        sendChannel.binaryType = \'arraybuffer\';\n        sendChannel.addEventListener(\'open\', () => {\n          if (sendChannel.readyState === \'open\') {\n            that.logs.push("建立连接 : channel open");\n          }\n        });\n        sendChannel.addEventListener(\'close\', () => {\n          if (sendChannel.readyState === \'close\') {\n            that.logs.push("连接关闭 : channel close");\n          }\n        });\n        sendChannel.addEventListener(\'error\', error => {\n          that.handlerSendChannelError(error);\n        });\n        this.rtcConns[id].addEventListener(\'datachannel\', event => {\n          that.initReceiveDataChannel(event, id);\n        });\n        this.setRemoteInfo(id, {\n          sendChannel: sendChannel\n        });\n      },\n      //处理发送过程中的错误情况\n      handlerSendChannelError: function (error) {\n        console.error(error.error);\n        this.logs.push("连接断开 : " + error);\n      },\n      //上传文件\n      submitChooseFile: function () {\n        this.initSendData();\n      },\n      //创建发送文件事件\n      initSendData: function () {\n        let that = this;\n\n        if (this.chooseFile == undefined || this.chooseFile == null) {\n          this.addPopup("请先选择文件");\n          this.logs.push("请先选择文件");\n          return;\n        }\n\n        this.fileReader = new FileReader();\n        this.fileReader.addEventListener(\'error\', error => {\n          that.logs.push("读取文件错误 : " + error);\n        });\n        this.fileReader.addEventListener(\'abort\', event => {\n          that.logs.push("读取文件中断 : " + event);\n        });\n        this.fileReader.addEventListener(\'load\', this.sendData);\n        this.readSlice(0);\n      },\n\n      /**\r\n       * 发送文件\r\n       * 0 : 未发送\r\n       * 1 : 发送中\r\n       * 2 : 已发送\r\n       * @param {*} event \r\n       */\n      sendData: function (event) {\n        let needSendingId = "";\n        let hasSend = false;\n\n        for (let id in this.remoteMap) {\n          let remote = this.remoteMap[id];\n          let status = remote.status || 0;\n\n          if (status === 1) {\n            //有正在发送中的\n            hasSend = true;\n            needSendingId = id;\n          }\n        }\n\n        if (!hasSend) {\n          //没有正在发送中的, 取出对应的还没发送的文件\n          let hasAllSended = true;\n\n          for (let id in this.remoteMap) {\n            let remote = this.remoteMap[id];\n            let status = remote.status || 0;\n\n            if (status === 0 || status === 1) {\n              this.allSended = false;\n              hasAllSended = false;\n            }\n          }\n\n          if (hasAllSended) {\n            //全部发送完毕\n            this.allSended = true;\n            this.hasSending = false;\n            return;\n          }\n\n          for (let id in this.remoteMap) {\n            //还有还没发送的\n            let remote = this.remoteMap[id];\n            let status = remote.status || 0;\n\n            if (status === 0) {\n              needSendingId = id;\n            }\n          }\n\n          this.setRemoteInfo(needSendingId, {\n            status: 1\n          }); //发送给下一个用户时更新状态\n        } else {\n          this.allSended = false;\n        }\n\n        if (needSendingId != \'\') {\n          this.hasSending = true;\n          let remote = this.remoteMap[needSendingId];\n          let status = remote.status || 0;\n\n          if (status === 1) {\n            //保证同一时间只能发送房间内对应的一个用户\n            let sendChannel = remote.sendChannel;\n\n            if (!sendChannel || sendChannel.readyState !== \'open\') {\n              return;\n            }\n\n            if (this.offset === 0) {\n              this.addPopup("正在发送给" + needSendingId.substr(0, 4) + ",0%。");\n              this.logs.push("正在发送给" + needSendingId.substr(0, 4) + ",0%。");\n              this.updateSendProcess(needSendingId, {\n                start: Date.now()\n              });\n            }\n\n            sendChannel.send(event.target.result);\n            this.offset += event.target.result.byteLength;\n            let currentSendFile = this.offset; //更新发送进度\n\n            this.updateSendProcess(needSendingId, {\n              process: parseInt(currentSendFile / this.chooseFile.size * 100)\n            }); //发送完一份重置相关数据 并且开启下一个\n\n            if (this.offset === this.chooseFile.size) {\n              console.log(needSendingId + "发送完毕");\n              this.addPopup("正在发送给" + needSendingId.substr(0, 4) + ",100%。");\n              this.logs.push("正在发送给" + needSendingId.substr(0, 4) + ",100%。");\n              this.socket.emit(\'message\', {\n                emitType: "sendDone",\n                room: this.roomId,\n                from: this.socketId,\n                size: this.chooseFile.size,\n                name: this.chooseFile.name,\n                type: this.chooseFile.type,\n                to: needSendingId\n              }); //更新发送进度\n\n              this.updateSendProcess(needSendingId, {\n                done: true\n              });\n              this.offset = 0;\n              this.setRemoteInfo(needSendingId, {\n                status: 2\n              });\n              this.submitChooseFile();\n            }\n          }\n        }\n      },\n      //文件分片 -- 点击发送时首次自动，后续就是收到ack回执后自动\n      readSlice: function (offset) {\n        const slice = this.chooseFile.slice(this.offset, offset + this.chunkSize);\n        this.fileReader.readAsArrayBuffer(slice);\n      },\n      //分片发送反馈ack\n      receivedAck: function (socketId, receivedSize) {\n        this.socket.emit(\'message\', {\n          emitType: "receivedAck",\n          room: this.roomId,\n          from: this.socketId,\n          offset: receivedSize,\n          chunkSize: this.chunkSize,\n          to: socketId\n        });\n      },\n      //创建接收文件事件\n      initReceiveDataChannel: function (event, id) {\n        if (!id || !event) {\n          return;\n        }\n\n        let currentRtc = this.getRemoteInfo(id);\n\n        if (currentRtc) {\n          let receiveChannel = event.channel;\n          receiveChannel.binaryType = \'arraybuffer\';\n\n          receiveChannel.onmessage = env => {\n            this.receiveData(env, id);\n          };\n\n          receiveChannel.onopen = () => {\n            const readyState = receiveChannel.readyState;\n\n            if (readyState === \'open\') {}\n          };\n\n          receiveChannel.onclose = () => {\n            const readyState = receiveChannel.readyState;\n\n            if (readyState === \'open\') {}\n          };\n\n          this.setRemoteInfo(id, {\n            receiveChannel: receiveChannel\n          });\n        }\n      },\n      //接收文件\n      receiveData: function (event, id) {\n        if (!event || !id) {\n          return;\n        }\n\n        let currentRtc = this.getRemoteInfo(id);\n        let receiveFiles = currentRtc.receiveFiles || {};\n        let name = receiveFiles.name;\n        let size = receiveFiles.size;\n        let type = receiveFiles.type; //获取数据存下本地\n\n        let receiveBuffer = currentRtc.receiveBuffer || new Array();\n        let receivedSize = currentRtc.receivedSize || 0;\n\n        if (receivedSize === 0) {\n          this.updateReceiveProcess(id, {\n            start: Date.now()\n          });\n        }\n\n        receiveBuffer.push(event.data);\n        receivedSize += event.data.byteLength;\n        this.$refs[\'receiveProgress\'].value = receivedSize;\n        this.setRemoteInfo(id, {\n          receiveBuffer: receiveBuffer,\n          receivedSize: receivedSize\n        });\n        this.currentReceiveSize += event.data.byteLength; //收到分片后反馈ack\n\n        this.receivedAck(id, receivedSize); //更新接收进度\n\n        this.updateReceiveProcess(id, {\n          process: parseInt(receivedSize / size * 100)\n        });\n\n        if (receivedSize === size) {\n          console.log("接收完毕");\n          this.shaking("iamtsm", 0, 4);\n          this.logs.push("接收完毕...");\n          this.$refs[\'receiveProgress\'].value = 0;\n          this.addPopup("文件[ " + name + " ]接收完毕，可点击右下角查看。"); //更新接收进度\n\n          this.updateReceiveProcess(id, {\n            style: \'color: #ff5722;text-decoration: underline;\',\n            href: URL.createObjectURL(new Blob(receiveBuffer), {\n              type: type\n            }),\n            done: true\n          }); //清除接收的数据缓存\n\n          this.setRemoteInfo(id, {\n            receiveBuffer: new Array(),\n            receivedSize: 0\n          });\n          this.currentReceiveSize = 0;\n        }\n      },\n      //关闭连接\n      closeDataChannels: function () {\n        for (let remote in this.remoteMap) {\n          let id = remote.id;\n          let sendChannel = remote.sendChannel;\n          let receiveChannel = remote.receiveChannel;\n\n          if (!id || !sendChannel || !receiveChannel) {\n            continue;\n          }\n\n          sendChannel.close();\n          receiveChannel.close();\n        }\n      },\n\n      //设置rtc缓存远程连接数据\n      setRemoteInfo(id, data) {\n        if (!id || !data) {\n          return;\n        }\n\n        let oldData = this.remoteMap[id];\n\n        if (oldData) {\n          Object.assign(oldData, data);\n          Vue.set(this.remoteMap, id, oldData);\n        }\n      },\n\n      //更新接收进度\n      updateReceiveProcess: function (id, data) {\n        for (let i = 0; i < this.receiveFileList.length; i++) {\n          let item = this.receiveFileList[i];\n\n          if (item.id === id && !item.done) {\n            data.cost = parseInt((Date.now() - item.start) / 1000);\n            Object.assign(this.receiveFileList[i], data);\n          }\n        }\n      },\n      //更新发送进度\n      updateSendProcess: function (id, data) {\n        for (let i = 0; i < this.sendFileList.length; i++) {\n          let item = this.sendFileList[i];\n\n          if (item.id === id && !item.done) {\n            data.cost = parseInt((Date.now() - item.start) / 1000);\n            Object.assign(this.sendFileList[i], data);\n          }\n        }\n      },\n\n      //获取rtc缓存远程连接数据\n      getRemoteInfo(id) {\n        if (!id) {\n          return;\n        }\n\n        return this.remoteMap[id];\n      },\n\n      //移除rtc连接\n      removeStream: function (rtcConnect, id, event) {\n        this.getOrCreateRtcConnect(id).close;\n        delete this.rtcConns[id];\n        delete this.remoteMap[id];\n      },\n      iceCandidate: function (rtcConnect, id, event) {\n        if (event.candidate != null) {\n          let message = {\n            from: this.socketId,\n            to: id,\n            room: this.roomId,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            sdp: event.candidate.candidate\n          };\n          this.socket.emit(\'candidate\', message);\n        }\n      },\n      offerSuccess: function (rtcConnect, id, offer) {\n        rtcConnect.setLocalDescription(offer).then(r => {});\n        let message = {\n          from: this.socketId,\n          to: id,\n          room: this.roomId,\n          sdp: offer.sdp\n        };\n        this.socket.emit(\'offer\', message);\n      },\n      offerFailed: function (rtcConnect, id, error) {\n        this.logs.push("offer失败," + error);\n      },\n      answerSuccess: function (rtcConnect, id, offer) {\n        rtcConnect.setLocalDescription(offer).then(r => {});\n        let message = {\n          from: this.socketId,\n          to: id,\n          room: this.roomId,\n          sdp: offer.sdp\n        };\n        this.socket.emit(\'answer\', message);\n      },\n      answerFailed: function (rtcConnect, id, error) {\n        this.logs.push("answer失败," + error);\n      },\n      addIceCandidateSuccess: function (res) {\n        this.logs.push("addIceCandidateSuccess成功," + res);\n      },\n      addIceCandidateFailed: function (err) {\n        this.logs.push("addIceCandidate失败," + err);\n      },\n      socketListener: function () {\n        let that = this;\n        this.socket.emit("count", {});\n        this.socket.on(\'created\', async function (data) {\n          that.logs.push("创建房间," + JSON.stringify(data));\n          that.socketId = data.id;\n          that.roomId = data.room;\n          that.recoderId = data.recoderId;\n\n          for (let i = 0; i < data[\'peers\'].length; i++) {\n            let otherSocketId = data[\'peers\'][i].id;\n            let rtcConnect = that.getOrCreateRtcConnect(otherSocketId);\n            rtcConnect.createOffer(that.options).then(offer => {\n              that.offerSuccess(rtcConnect, otherSocketId, offer);\n            }, error => {\n              that.offerFailed(rtcConnect, otherSocketId, error);\n            });\n          }\n\n          that.touchResize();\n        });\n        this.socket.on(\'joined\', function (data) {\n          that.logs.push("加入房间," + JSON.stringify(data));\n          that.recoderId = data.recoderId;\n          that.getOrCreateRtcConnect(data.from);\n          that.addPopup(data.id + "加入了房间。");\n          that.touchResize();\n        });\n        this.socket.on(\'offer\', function (data) {\n          that.logs.push("offer," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcDescription = {\n            type: \'offer\',\n            sdp: data.sdp\n          };\n          rtcConnect.setRemoteDescription(new RTCSessionDescription(rtcDescription)).then(r => {});\n          rtcConnect.createAnswer(that.options).then(offer => {\n            that.answerSuccess(rtcConnect, data.from, offer);\n          }).catch(error => {\n            that.answerFailed(rtcConnect, data.from, error);\n          });\n        });\n        this.socket.on(\'answer\', function (data) {\n          that.logs.push("answer," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcDescription = {\n            type: \'answer\',\n            sdp: data.sdp\n          };\n          rtcConnect.setRemoteDescription(new RTCSessionDescription(rtcDescription)).then(r => {});\n        });\n        this.socket.on(\'candidate\', function (data) {\n          that.logs.push("candidate," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcIceCandidate = new RTCIceCandidate({\n            candidate: data.sdp,\n            sdpMid: data.sdpMid,\n            sdpMLineIndex: data.sdpMLineIndex\n          });\n          rtcConnect.addIceCandidate(rtcIceCandidate).then(res => {\n            that.addIceCandidateSuccess(res);\n          }).catch(error => {\n            that.addIceCandidateFailed(error);\n          });\n        });\n        this.socket.on(\'exit\', function (data) {\n          var rtcConnect = that.rtcConns[data.from];\n\n          if (typeof rtcConnect == \'undefined\') {\n            return;\n          } else {\n            that.addPopup(data.from + "退出了房间。");\n            that.logs.push("退出房间," + JSON.stringify(data));\n            that.getOrCreateRtcConnect(data.from).close;\n            delete that.rtcConns[data.from];\n            Vue.delete(that.remoteMap, data.from);\n          }\n\n          that.touchResize();\n        }); //选中文件时发送给接收方\n\n        this.socket.on(\'sendFileInfo\', function (data) {\n          let fromId = data.from;\n          that.setRemoteInfo(fromId, {\n            receiveFiles: data\n          });\n          that.addPopup(data.from + "选择了文件 [ " + data.name + " ]，即将发送。");\n          that.logs.push(data.from + "选择了文件 [ " + data.name + " ]，即将发送。");\n          that.$refs[\'receiveProgress\'].max = data.size;\n          that.receiveFileList.push({\n            id: fromId,\n            href: "",\n            name: data.name,\n            type: data.type,\n            size: data.size,\n            process: 0,\n            done: false,\n            start: 0,\n            cost: 0\n          });\n        }); //收到文件回传ack，继续分片回传\n\n        this.socket.on(\'receivedAck\', function (data) {\n          let to = data.to;\n\n          if (to === that.socketId) {\n            if (that.offset < that.chooseFile.size) {\n              that.readSlice(that.offset);\n            }\n          }\n        }); //发送文字内容\n\n        this.socket.on(\'sendTxt\', function (data) {\n          let fromId = data.from;\n          that.addPopup(data.from + "发送了文字 [ " + data.content.substr(0, 10) + " ]");\n          that.logs.push(data.from + "发送了文字 [ " + data.content.substr(0, 10) + " ]");\n          that.receiveTxtList.push({\n            id: fromId,\n            content: decodeURIComponent(data.content),\n            time: new Date().toLocaleString(),\n            c_id: "txt_" + that.receiveTxtList.length,\n            process: 0,\n            done: false,\n            start: 0,\n            cost: 0\n          });\n        }); //在线数量\n\n        this.socket.on(\'count\', function (data) {\n          that.allManCount = data.mc;\n        }); //公共聊天频道\n\n        this.socket.on(\'chating\', function (data) {\n          that.logs.push(data.room + "频道的" + data.socketId + "发言: [ " + data.msg + " ]");\n          data.msg = that.escapeHtml().escape(data.msg);\n          that.chatingList.push(data);\n          that.chatingTpl();\n        });\n      },\n      initCss: function (e) {\n        if (!e) return;\n\n        if (this.currentMenu === 1) {\n          this.clickHome(false);\n        } else if (this.currentMenu === 2) {\n          this.clickReceive(false);\n        } else if (this.currentMenu === 3) {\n          this.clickTxt(false);\n        } //re caculate size\n\n\n        this.reCaculateSwiperSize();\n        this.logsHeight = document.documentElement.clientHeight - 55;\n      },\n      loadJS: function (url, callback) {\n        var script = document.createElement(\'script\'),\n            fn = callback || function () {};\n\n        script.type = \'text/javascript\'; //IE\n\n        if (script.readyState) {\n          script.onreadystatechange = function () {\n            if (script.readyState == \'loaded\' || script.readyState == \'complete\') {\n              script.onreadystatechange = null;\n              fn();\n            }\n          };\n        } else {\n          //其他浏览器\n          script.onload = function () {\n            fn();\n          };\n        }\n\n        script.src = url;\n        document.getElementsByTagName(\'head\')[0].appendChild(script);\n      },\n      reCaculateSwiperSize: function () {\n        let clientWidth = document.body.clientWidth;\n        let slidesPerView = parseInt(clientWidth / 100) - 1;\n\n        if (window.swiper) {\n          window.swiper.params.slidesPerView = slidesPerView;\n        }\n      },\n      touchResize: function () {\n        let that = this;\n        setTimeout(() => {\n          var myEvent = new Event(\'resize\');\n          window.dispatchEvent(myEvent);\n          that.reCaculateSwiperSize();\n        }, 100);\n      },\n      shaking: function (id, top, left) {\n        let a = [\'maringTop\', \'marginLeft\'],\n            b = 0;\n        window.shakingId = setInterval(function () {\n          document.getElementById(id).style[a[b % 2]] = b++ % 4 < 2 ? top + "px" : left + "px";\n\n          if (b > 15) {\n            clearInterval(window.shakingId);\n            b = 0;\n          }\n        }, 32);\n      }\n    },\n    created: function () {\n      let that = this;\n\n      if (window.location.hash && window.location.hash.includes("debug")) {\n        this.loadJS(\'/static/js/vconsole.min.js\', function () {\n          that.loadJS(\'/static/js/vconsole.js\', function () {\n            console.log("load vconsole success");\n          });\n        });\n      }\n\n      setTimeout(() => {\n        that.handlerRoomHistory();\n      }, 200);\n    },\n    mounted: function () {\n      this.$nextTick(() => {\n        this.logs.push("socket 初始化中...");\n        this.socketListener();\n        this.logs.push("socket 初始化成功");\n      });\n      this.clickHome(false);\n      window.onresize = this.initCss;\n      window.Bus.$on("changeScreenState", res => {\n        this.isScreen = res;\n      });\n      window.Bus.$on("changeScreenTimes", res => {\n        this.screenTimes = res;\n      });\n      window.Bus.$on("sendChating", res => {\n        this.sendChating();\n      });\n    },\n    destroyed: function () {}\n  });\n\n  window.sendChating = function () {\n    window.Bus.$emit("sendChating", {});\n  };\n});\n\n//# sourceURL=webpack:///D:/project/tl-open-source/tl-rtc-file-git/res/js/index.js?')}],g={},h.m=f,h.c=g,h.d=function(n,e,t){h.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},h.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},h.t=function(e,n){if(1&n&&(e=h(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(h.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)h.d(t,i,function(n){return e[n]}.bind(null,i));return t},h.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return h.d(e,"a",e),e},h.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},h.p="",h(h.s=0);function h(n){if(g[n])return g[n].exports;var e=g[n]={i:n,l:!1,exports:{}};return f[n].call(e.exports,e,e.exports,h),e.l=!0,e.exports}var f,g});