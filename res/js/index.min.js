!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t,i=e();for(t in i)("object"==typeof exports?exports:n)[t]=i[t]}}(this,function(){return function(t){var i={};function o(n){if(i[n])return i[n].exports;var e=i[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,o),e.l=!0,e.exports}return o.m=t,o.c=i,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)o.d(t,i,function(n){return e[n]}.bind(null,i));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="",o(o.s=0)}([function(module,exports){eval('// file.js\nvar file = null;\naxios.get(window.prefix + "/api/comm/initData", {}).then(initData => {\n  let resData = initData.data;\n  file = new Vue({\n    el: \'#fileApp\',\n    data: function () {\n      let socket = null;\n\n      if (io) {\n        socket = io(resData.wsHost);\n      }\n\n      return {\n        socket: socket,\n        config: resData.rtcConfig,\n        options: resData.options,\n        isJoined: false,\n        showReceiveFile: false,\n        showSendFile: false,\n        showLogs: false,\n        numSendFile: 150,\n        numReceiveFile: 150,\n        numLogs: 150,\n        currentMenu: 1,\n        logsHeight: 0,\n        nickName: "",\n        //本人名称\n        socketId: 0,\n        //本人的id\n        roomId: "10086",\n        //房间号\n        fileReader: null,\n        //文件读取对象\n        rtcConns: {},\n        //远程连接\n        remoteMap: {},\n        //远程连接map\n        allManCount: 0,\n        //在线人数\n        chunkSize: 256 * 1024,\n        //一块256kb\n        offset: 0,\n        //当前文件分片位移\n        fileName: null,\n        //文件名称\n        allSended: false,\n        //当前文件是否全部发送给房间内所有用户\n        currentReceiveSize: 0,\n        //统计收到文件的大小\n        hasSending: "",\n        //是否有正在发送的文件\n        chooseFile: null,\n        //选择的文件\n        sendFileList: [],\n        //发过文件的列表\n        receiveFileList: [],\n        //接收文件的列表\n        logs: [] //记录日志\n\n      };\n    },\n    computed: {\n      createDisabled: function () {\n        return this.isJoined || this.fileName;\n      },\n      exsitDisabled: function () {\n        return !this.isJoined;\n      },\n      sending: function () {\n        return this.hasSending;\n      },\n      uploadDisabled: function () {\n        return !this.fileName || this.allSended;\n      },\n      showSendFileList: function () {\n        return this.sendFileList && this.sendFileList.length > 5;\n      },\n      noOthersInRoom: function () {\n        return Object.keys(this.remoteMap).length === 0;\n      }\n    },\n    watch: {\n      allManCount: function (newV, oldV) {},\n      hasSending: function (newV, oldV) {},\n      currentMenu: function (newV, oldV) {},\n      allSended: function (newV, oldV) {},\n      fileName: function (newV, oldV) {\n        this.chooseFile = this.$refs[\'self-file\'].files[0];\n        if (!this.chooseFile) return;\n        if (!this.socketId) return;\n        this.$refs[\'sendProgress\'].max = this.chooseFile.size;\n        this.socket.emit(\'message\', {\n          emitType: "sendFileInfo",\n          name: this.chooseFile.name,\n          type: this.chooseFile.type,\n          size: this.chooseFile.size,\n          room: this.roomId,\n          from: this.socketId\n        });\n        this.allSended = false;\n        let idList = [];\n\n        for (let id in this.remoteMap) {\n          this.setRemoteInfo(id, {\n            status: 0\n          });\n          idList.push(id);\n        }\n\n        if (this.socketId) {\n          let toIdStr = "";\n\n          if (idList.length > 0) {\n            toIdStr += "发送给房间的 " + idList[0] + " ...等" + idList.length + "人";\n          }\n\n          for (let id in this.remoteMap) {\n            this.sendFileList.push({\n              id: id,\n              name: this.chooseFile.name,\n              size: this.chooseFile.size,\n              type: this.chooseFile.type,\n              process: 0,\n              done: false,\n              toIdStr: toIdStr\n            });\n          }\n        }\n      },\n      currentReceiveSize: function (newV, oldV) {\n        this.currentReceiveSize = newV;\n      },\n      remoteMap: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      receiveFileList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      },\n      sendFileList: {\n        handler: function (newV, oldV) {},\n        deep: true,\n        immediate: true\n      }\n    },\n    methods: {\n      refleshRoom: function () {\n        if (!this.createDisabled) {\n          this.roomId = parseInt(Math.random() * 100000);\n          this.addPopup("你刷新了房间号, 当前房间号为 " + this.roomId);\n          this.logs.push("你刷新了房间号, 当前房间号为 " + this.roomId);\n        }\n      },\n      genNickName: function () {\n        // 获取指定范围内的随机数\n        function randomAccess(min, max) {\n          return Math.floor(Math.random() * (min - max) + max);\n        } // 解码\n\n\n        function decodeUnicode(str) {\n          //Unicode显示方式是\\u4e00\n          str = "\\\\u" + str;\n          str = str.replace(/\\\\/g, "%"); //转换中文\n\n          str = unescape(str); //将其他受影响的转换回原来\n\n          str = str.replace(/%/g, "\\\\");\n          return str;\n        }\n\n        function getRandomName(len) {\n          let name = "";\n\n          for (let i = 0; i < len; i++) {\n            let unicodeNum = "";\n            unicodeNum = randomAccess(0x4e00, 0x9fa5).toString(16);\n            name += decodeUnicode(unicodeNum);\n          }\n\n          return name;\n        }\n\n        return getRandomName(4);\n      },\n      addPopup: function (msg) {\n        window.Bus.$emit("addPopup", msg);\n      },\n      cleanPopup: function () {\n        window.Bus.$emit("popupMap");\n      },\n      clickChooseFile: function () {\n        this.$refs[\'self-file\'].click();\n\n        if (!this.createDisabled) {\n          this.addPopup("请先创建/加入房间后，再选择文件");\n          this.logs.push("请先创建/加入房间后，再选择文件");\n        }\n      },\n      clickHome: function (show = true) {\n        this.currentMenu = 1;\n        let body = document.body;\n        let menuBorder = document.querySelector(".menu__border");\n        let active = this.$refs[\'btnHome\'];\n        let box = active.getBoundingClientRect();\n        body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        document.querySelector(".chooseFileName").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickSendFile();\n        }\n      },\n      clickRoom: function (show = true) {\n        this.currentMenu = 2;\n        let body = document.body;\n        let menuBorder = document.querySelector(".menu__border");\n        let active = this.$refs[\'btnRoom\'];\n        let box = active.getBoundingClientRect();\n        body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        document.querySelector(".chooseFileName").style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickReceiveFile();\n        }\n      },\n      clickFile: function (show = true) {\n        this.currentMenu = 3;\n        let body = document.body;\n        let menuBorder = document.querySelector(".menu__border");\n        let active = this.$refs[\'btnFile\'];\n        let box = active.getBoundingClientRect();\n        body.style.backgroundColor = active.style.getPropertyValue("--bgColorBody");\n        offsetMenuBorder(box, menuBorder);\n\n        function offsetMenuBorder(box, menuBorder) {\n          let left = Math.floor(box.left - menuBorder.closest("menu").offsetLeft - (menuBorder.offsetWidth - box.width) / 2) + "px";\n          menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;\n        }\n\n        if (show) {\n          this.clickReceiveFile();\n        }\n      },\n      //文件大小\n      getFileSizeStr: function (size) {\n        let sizeStr = (size / 1048576).toString();\n        let head = sizeStr.split(".")[0];\n        let tail = "";\n\n        if (sizeStr.split(".")[1]) {\n          tail = sizeStr.split(".")[1].substr(0, 3);\n        }\n\n        return head + \'.\' + tail + "M";\n      },\n      //点击下载文件\n      clickReceiveFile: function () {\n        this.showReceiveFile = !this.showReceiveFile;\n\n        if (this.showReceiveFile) {\n          this.numReceiveFile = 50;\n        } else {\n          this.numReceiveFile = 150;\n        }\n      },\n      //点击发送文件\n      clickSendFile: function () {\n        this.showSendFile = !this.showSendFile;\n\n        if (this.showSendFile) {\n          this.numSendFile = 50;\n        } else {\n          this.numSendFile = 150;\n        }\n      },\n      //点击查看日志\n      clickLogs: function () {\n        this.showLogs = !this.showLogs;\n\n        if (this.showLogs) {\n          this.numLogs = 50;\n        } else {\n          this.numLogs = 150;\n        }\n      },\n      //创建房间\n      createRoom: function () {\n        this.roomId = this.roomId.toString().replace(/\\s*/g, "");\n\n        if (this.roomId === null || this.roomId === undefined || this.roomId === \'\') {\n          alert("请先填写房间号");\n          return;\n        }\n\n        if (this.fileName != null) {\n          alert("请先加入房间再选文件");\n          return;\n        }\n\n        if (this.roomId) {\n          if (this.roomId.toString().length > 15) {\n            alert("房间号太长啦");\n            return;\n          }\n\n          this.socket.emit(\'createAndJoin\', {\n            room: this.roomId\n          });\n          this.isJoined = true; // this.nickName = this.genNickName();\n\n          this.addPopup("你进入了房间" + this.roomId);\n          this.logs.push("你进入了房间" + this.roomId);\n        }\n      },\n      //退出房间\n      exitRoom: function () {\n        if (this.roomId) {\n          this.socket.emit(\'exit\', {\n            from: this.socketId,\n            room: this.roomId\n          });\n        }\n\n        for (let i in this.rtcConns) {\n          let rtcConnect = this.rtcConns[i];\n          rtcConnect.close();\n          rtcConnect = null;\n        }\n\n        window.location.reload();\n      },\n      //获取rtc缓存连接\n      getRtcConnect: function (id) {\n        return this.rtcConns[id];\n      },\n      //创立链接\n      createRtcConnect: function (id) {\n        if (id === undefined) {\n          return;\n        }\n\n        let that = this;\n        let rtcConnect = new RTCPeerConnection(this.config);\n\n        rtcConnect.onicecandidate = e => {\n          that.iceCandidate(rtcConnect, id, e);\n        }; //保存peer连接\n\n\n        this.rtcConns[id] = rtcConnect;\n\n        if (!this.remoteMap[id]) {\n          Vue.set(this.remoteMap, id, {\n            id: id\n          });\n        } //数据通道\n\n\n        this.initSendDataChannel(id);\n\n        rtcConnect.onremovestream = e => {\n          that.removeStream(rtcConnect, id, e);\n        };\n\n        return rtcConnect;\n      },\n      //获取本地与远程连接\n      getOrCreateRtcConnect: function (id) {\n        let rtcConnect = this.getRtcConnect(id);\n\n        if (typeof rtcConnect == \'undefined\') {\n          rtcConnect = this.createRtcConnect(id);\n        }\n\n        return rtcConnect;\n      },\n      //连接创立时建立 send/receive Channel链接\n      initSendDataChannel: function (id) {\n        let that = this;\n        let sendChannel = this.rtcConns[id].createDataChannel(\'sendDataChannel\');\n        sendChannel.binaryType = \'arraybuffer\';\n        sendChannel.addEventListener(\'open\', () => {\n          if (sendChannel.readyState === \'open\') {\n            that.logs.push("建立连接 : channel open");\n          }\n        });\n        sendChannel.addEventListener(\'close\', () => {\n          if (sendChannel.readyState === \'close\') {\n            that.logs.push("连接关闭 : channel close");\n          }\n        });\n        sendChannel.addEventListener(\'error\', error => {\n          that.handlerSendChannelError(error);\n        });\n        this.rtcConns[id].addEventListener(\'datachannel\', event => {\n          that.initReceiveDataChannel(event, id);\n        });\n        this.setRemoteInfo(id, {\n          sendChannel: sendChannel\n        });\n      },\n      //处理发送过程中的错误情况\n      handlerSendChannelError: function (error) {\n        console.error(error.error);\n        this.logs.push("连接断开 : " + error);\n      },\n      //上传文件\n      submitChooseFile: function () {\n        this.initSendData();\n      },\n      //创建发送文件事件\n      initSendData: function () {\n        let that = this;\n\n        if (this.chooseFile == undefined || this.chooseFile == null) {\n          this.logs.push("请先选择文件");\n          return;\n        }\n\n        this.fileReader = new FileReader();\n        this.fileReader.addEventListener(\'error\', error => {\n          that.logs.push("读取文件错误 : " + error);\n        });\n        this.fileReader.addEventListener(\'abort\', event => {\n          that.logs.push("读取文件中断 : " + event);\n        });\n        this.fileReader.addEventListener(\'load\', this.sendData);\n        this.readSlice(0);\n      },\n\n      /**\r\n       * 发送文件\r\n       * 0 : 未发送\r\n       * 1 : 发送中\r\n       * 2 : 已发送\r\n       * @param {*} event \r\n       */\n      sendData: function (event) {\n        let needSendingId = "";\n        let hasSending = false;\n\n        for (let id in this.remoteMap) {\n          let remote = this.remoteMap[id];\n          let status = remote.status || 0;\n\n          if (status === 1) {\n            //有正在发送中的\n            hasSending = true;\n            needSendingId = id;\n          }\n        }\n\n        let that = this; // hasSending = Object.keys(Object.keys(remoteMap).filter((id)=>{\n        //     return that.remoteMap[id].status === 1;\n        // }));\n\n        if (!hasSending) {\n          //没有正在发送中的, 取出对应的还没发送的文件\n          let hasAllSended = true;\n\n          for (let id in this.remoteMap) {\n            let remote = this.remoteMap[id];\n            let status = remote.status || 0;\n\n            if (status === 0 || status === 1) {\n              hasAllSended = false;\n              this.allSended = true;\n            }\n          }\n\n          if (hasAllSended) {\n            //全部发送完毕\n            this.allSended = true;\n            this.hasSending = false;\n            return;\n          }\n\n          for (let id in this.remoteMap) {\n            //还有还没发送的\n            let remote = this.remoteMap[id];\n            let status = remote.status || 0;\n\n            if (status === 0) {\n              needSendingId = id;\n            }\n          }\n\n          this.setRemoteInfo(needSendingId, {\n            status: 1\n          }); //发送给下一个用户时更新状态\n        }\n\n        if (needSendingId != \'\') {\n          this.hasSending = true;\n          let remote = this.remoteMap[needSendingId];\n          let status = remote.status || 0;\n\n          if (status === 1) {\n            //保证同一时间只能发送房间内对应的一个用户\n            let sendChannel = remote.sendChannel;\n\n            if (!sendChannel || sendChannel.readyState !== \'open\') {\n              return;\n            }\n\n            if (this.offset === 0) {\n              this.addPopup("正在发送给" + needSendingId.substr(0, 4) + ",0%。");\n              this.logs.push("正在发送给" + needSendingId.substr(0, 4) + ",0%。");\n            }\n\n            sendChannel.send(event.target.result);\n            this.offset += event.target.result.byteLength;\n            let currentSendFile = this.offset; //更新发送进度\n\n            this.updateSendProcess(needSendingId, {\n              process: parseInt(currentSendFile / this.chooseFile.size * 100)\n            }); //发送完一份重置相关数据 并且开启下一个\n\n            if (this.offset === this.chooseFile.size) {\n              console.log(needSendingId + "发送完毕");\n              this.addPopup("正在发送给" + needSendingId.substr(0, 4) + ",100%。");\n              this.logs.push("正在发送给" + needSendingId.substr(0, 4) + ",100%。"); //更新发送进度\n\n              this.updateSendProcess(needSendingId, {\n                done: true\n              });\n              this.offset = 0;\n              this.setRemoteInfo(needSendingId, {\n                status: 2\n              });\n              this.submitChooseFile();\n            }\n          }\n        }\n      },\n      //文件分片 -- 点击发送时首次自动，后续就是收到ack回执后自动\n      readSlice: function (offset) {\n        const slice = this.chooseFile.slice(this.offset, offset + this.chunkSize);\n        this.fileReader.readAsArrayBuffer(slice);\n      },\n      //分片发送反馈ack\n      receivedAck: function (socketId, receivedSize) {\n        this.socket.emit(\'message\', {\n          emitType: "receivedAck",\n          room: this.roomId,\n          from: this.socketId,\n          offset: receivedSize,\n          chunkSize: this.chunkSize,\n          to: socketId\n        });\n      },\n      //创建接收文件事件\n      initReceiveDataChannel: function (event, id) {\n        if (!id || !event) {\n          return;\n        }\n\n        let currentRtc = this.getRemoteInfo(id);\n\n        if (currentRtc) {\n          let receiveChannel = event.channel;\n          receiveChannel.binaryType = \'arraybuffer\';\n\n          receiveChannel.onmessage = env => {\n            this.receiveData(env, id);\n          };\n\n          receiveChannel.onopen = () => {\n            const readyState = receiveChannel.readyState;\n\n            if (readyState === \'open\') {}\n          };\n\n          receiveChannel.onclose = () => {\n            const readyState = receiveChannel.readyState;\n\n            if (readyState === \'open\') {}\n          };\n\n          this.setRemoteInfo(id, {\n            receiveChannel: receiveChannel\n          });\n        }\n      },\n      //接收文件\n      receiveData: function (event, id) {\n        if (!event || !id) {\n          return;\n        }\n\n        let currentRtc = this.getRemoteInfo(id);\n        let receiveFiles = currentRtc.receiveFiles || {};\n        let name = receiveFiles.name;\n        let size = receiveFiles.size;\n        let type = receiveFiles.type; //获取数据存下本地\n\n        let receiveBuffer = currentRtc.receiveBuffer || [];\n        let receivedSize = currentRtc.receivedSize || 0;\n        receiveBuffer.push(event.data);\n        receivedSize += event.data.byteLength;\n        this.$refs[\'receiveProgress\'].value = receivedSize;\n        this.setRemoteInfo(id, {\n          receiveBuffer: receiveBuffer,\n          receivedSize: receivedSize\n        });\n        this.currentReceiveSize += event.data.byteLength; //收到分片后反馈ack\n\n        this.receivedAck(id, receivedSize); //更新接收进度\n\n        this.updateReceiveProcess(id, {\n          process: parseInt(receivedSize / size * 100)\n        });\n\n        if (receivedSize === size) {\n          console.log("接收完毕");\n          this.logs.push("接收完毕...");\n          this.$refs[\'receiveProgress\'].value = 0;\n          this.addPopup("文件[ " + name + " ]接收完毕，可点击右下角查看。"); //更新接收进度\n\n          this.updateReceiveProcess(id, {\n            style: \'color: #ff5722;text-decoration: underline;\',\n            href: URL.createObjectURL(new Blob(receiveBuffer), {\n              type: type\n            }),\n            done: true\n          }); //清除接收的数据缓存\n\n          this.setRemoteInfo(id, {\n            receiveBuffer: [],\n            receivedSize: 0\n          });\n          this.currentReceiveSize = 0;\n        }\n      },\n      //关闭连接\n      closeDataChannels: function () {\n        for (let remote in this.remoteMap) {\n          let id = remote.id;\n          let sendChannel = remote.sendChannel;\n          let receiveChannel = remote.receiveChannel;\n\n          if (!id || !sendChannel || !receiveChannel) {\n            continue;\n          }\n\n          sendChannel.close();\n          receiveChannel.close();\n        }\n      },\n\n      //设置rtc缓存远程连接数据\n      setRemoteInfo(id, data) {\n        if (!id || !data) {\n          return;\n        }\n\n        let oldData = this.remoteMap[id];\n\n        if (oldData) {\n          Object.assign(oldData, data);\n          Vue.set(this.remoteMap, id, oldData);\n        }\n      },\n\n      //更新接收进度\n      updateReceiveProcess: function (id, data) {\n        for (let i = 0; i < this.receiveFileList.length; i++) {\n          let item = this.receiveFileList[i];\n\n          if (item.id === id && !item.done) {\n            Object.assign(this.receiveFileList[i], data);\n          }\n        }\n      },\n      //更新发送进度\n      updateSendProcess: function (id, data) {\n        for (let i = 0; i < this.sendFileList.length; i++) {\n          let item = this.sendFileList[i];\n\n          if (item.id === id && !item.done) {\n            Object.assign(this.sendFileList[i], data);\n          }\n        }\n      },\n\n      //获取rtc缓存远程连接数据\n      getRemoteInfo(id) {\n        if (!id) {\n          return;\n        }\n\n        return this.remoteMap[id];\n      },\n\n      //移除rtc连接\n      removeStream: function (rtcConnect, id, event) {\n        this.getOrCreateRtcConnect(id).close;\n        delete this.rtcConns[id];\n        delete this.remoteMap[id];\n      },\n      iceCandidate: function (rtcConnect, id, event) {\n        if (event.candidate != null) {\n          let message = {\n            from: this.socketId,\n            to: id,\n            room: this.roomId,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            sdp: event.candidate.candidate\n          };\n          this.socket.emit(\'candidate\', message);\n        }\n      },\n      offerSuccess: function (rtcConnect, id, offer) {\n        rtcConnect.setLocalDescription(offer).then(r => {});\n        let message = {\n          from: this.socketId,\n          to: id,\n          room: this.roomId,\n          sdp: offer.sdp\n        };\n        this.socket.emit(\'offer\', message);\n      },\n      offerFailed: function (rtcConnect, id, error) {\n        this.logs.push("offer失败," + error);\n      },\n      answerSuccess: function (rtcConnect, id, offer) {\n        rtcConnect.setLocalDescription(offer).then(r => {});\n        let message = {\n          from: this.socketId,\n          to: id,\n          room: this.roomId,\n          sdp: offer.sdp\n        };\n        this.socket.emit(\'answer\', message);\n      },\n      answerFailed: function (rtcConnect, id, error) {\n        this.logs.push("answer失败," + error);\n      },\n      addIceCandidateSuccess: function (res) {\n        this.logs.push("addIceCandidateSuccess成功," + res);\n      },\n      addIceCandidateFailed: function (err) {\n        this.logs.push("addIceCandidate失败," + err);\n      },\n      socketListener: function () {\n        let that = this;\n        this.socket.on(\'created\', async function (data) {\n          that.logs.push("创建房间," + JSON.stringify(data));\n          that.socketId = data.id;\n          that.roomId = data.room;\n\n          for (let i = 0; i < data[\'peers\'].length; i++) {\n            let otherSocketId = data[\'peers\'][i].id;\n            let rtcConnect = that.getOrCreateRtcConnect(otherSocketId);\n            rtcConnect.createOffer(that.options).then(offer => {\n              that.offerSuccess(rtcConnect, otherSocketId, offer);\n            }, error => {\n              that.offerFailed(rtcConnect, otherSocketId, error);\n            });\n          }\n\n          that.touchResize();\n        });\n        this.socket.on(\'joined\', function (data) {\n          that.logs.push("加入房间," + JSON.stringify(data));\n          that.getOrCreateRtcConnect(data.from);\n          that.addPopup(data.id + "加入了房间。");\n          that.touchResize();\n        });\n        this.socket.on(\'offer\', function (data) {\n          that.logs.push("offer," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcDescription = {\n            type: \'offer\',\n            sdp: data.sdp\n          };\n          rtcConnect.setRemoteDescription(new RTCSessionDescription(rtcDescription)).then(r => {});\n          rtcConnect.createAnswer(that.options).then(offer => {\n            that.answerSuccess(rtcConnect, data.from, offer);\n          }).catch(error => {\n            that.answerFailed(rtcConnect, data.from, error);\n          });\n        });\n        this.socket.on(\'answer\', function (data) {\n          that.logs.push("answer," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcDescription = {\n            type: \'answer\',\n            sdp: data.sdp\n          };\n          rtcConnect.setRemoteDescription(new RTCSessionDescription(rtcDescription)).then(r => {});\n        });\n        this.socket.on(\'candidate\', function (data) {\n          that.logs.push("candidate," + JSON.stringify(data));\n          let rtcConnect = that.getOrCreateRtcConnect(data.from);\n          let rtcIceCandidate = new RTCIceCandidate({\n            candidate: data.sdp,\n            sdpMid: data.sdpMid,\n            sdpMLineIndex: data.sdpMLineIndex\n          });\n          rtcConnect.addIceCandidate(rtcIceCandidate).then(res => {\n            that.addIceCandidateSuccess(res);\n          }).catch(error => {\n            that.addIceCandidateFailed(error);\n          });\n        });\n        this.socket.on(\'exit\', function (data) {\n          var rtcConnect = that.rtcConns[data.from];\n\n          if (typeof rtcConnect == \'undefined\') {\n            return;\n          } else {\n            that.addPopup(data.from + "退出了房间。");\n            that.logs.push("退出房间," + JSON.stringify(data));\n            that.getOrCreateRtcConnect(data.from).close;\n            delete that.rtcConns[data.from];\n            Vue.delete(that.remoteMap, data.from);\n          }\n\n          that.touchResize();\n        }); //选中文件时发送给接收方\n\n        this.socket.on(\'sendFileInfo\', function (data) {\n          let fromId = data.from;\n          that.setRemoteInfo(fromId, {\n            receiveFiles: data\n          });\n          that.addPopup(data.from + "选择了文件 [ " + data.name + " ]，即将发送。");\n          that.logs.push(data.from + "选择了文件 [ " + data.name + " ]，即将发送。");\n          that.$refs[\'receiveProgress\'].max = data.size;\n          that.receiveFileList.push({\n            id: fromId,\n            href: "",\n            name: data.name,\n            type: data.type,\n            size: data.size,\n            process: 0,\n            done: false\n          });\n        }); //收到文件回传ack，继续分片回传\n\n        this.socket.on(\'receivedAck\', function (data) {\n          let to = data.to;\n\n          if (to === that.socketId) {\n            if (that.offset < that.chooseFile.size) {\n              that.readSlice(that.offset);\n            }\n          }\n        }); //在线数量\n\n        this.socket.on(\'count\', function (data) {\n          that.allManCount = data.mc;\n        });\n      },\n      initCss: function (e) {\n        if (!e) return;\n\n        if (this.currentMenu === 1) {\n          this.clickHome(false);\n        } else if (this.currentMenu === 2) {\n          this.clickRoom(false);\n        } else if (this.currentMenu === 3) {\n          this.clickFile(false);\n        } //re caculate size\n\n\n        this.reCaculateSwiperSize();\n        this.logsHeight = document.documentElement.clientHeight - 55;\n      },\n      loadJS: function (url, callback) {\n        var script = document.createElement(\'script\'),\n            fn = callback || function () {};\n\n        script.type = \'text/javascript\'; //IE\n\n        if (script.readyState) {\n          script.onreadystatechange = function () {\n            if (script.readyState == \'loaded\' || script.readyState == \'complete\') {\n              script.onreadystatechange = null;\n              fn();\n            }\n          };\n        } else {\n          //其他浏览器\n          script.onload = function () {\n            fn();\n          };\n        }\n\n        script.src = url;\n        document.getElementsByTagName(\'head\')[0].appendChild(script);\n      },\n      reCaculateSwiperSize: function () {\n        let clientWidth = document.body.clientWidth;\n        let slidesPerView = parseInt(clientWidth / 100) - 1;\n\n        if (window.swiper) {\n          window.swiper.params.slidesPerView = slidesPerView;\n        }\n      },\n      touchResize: function () {\n        let that = this;\n        setTimeout(() => {\n          var myEvent = new Event(\'resize\');\n          window.dispatchEvent(myEvent);\n          that.reCaculateSwiperSize();\n        }, 100);\n      }\n    },\n    created: function () {\n      let that = this;\n\n      if (window.location.hash && window.location.hash.includes("debug")) {\n        this.loadJS(\'/static/js/vconsole.min.js\', function () {\n          that.loadJS(\'/static/js/vconsole.js\', function () {\n            console.log("load vconsole success");\n          });\n        });\n      }\n    },\n    mounted: function () {\n      this.$nextTick(() => {\n        this.logs.push("socket 初始化中...");\n        this.socketListener();\n        this.logs.push("socket 初始化成功");\n      });\n      this.clickHome(false);\n      window.onresize = this.initCss;\n    },\n    destroyed: function () {}\n  });\n});\n\n//# sourceURL=webpack:///F:/code/tl-open-source/tl-rtc-file-git/res/js/index.js?')}])});